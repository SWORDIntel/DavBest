# DavBest Sensor Module: Design Document

## 1. Introduction and Purpose

This document outlines the design for the "DavBest Sensor Module," a component adapted from the conceptual `validation_module.c`. Its primary purpose is to perform **defensive integrity validation** of host system configurations from within potentially untrusted environments, such as containers.

The module operates by attempting to perform actions that *should be denied* by robust host-container isolation policies. These attempts are termed "integrity verification probes." An unexpected success of any probe (e.g., successfully writing to a protected host path) indicates a potential security vulnerability or misconfiguration, which will be logged as a critical integrity anomaly.

## 2. Core Operational Logic

The DavBest Sensor Module will execute a series of predefined integrity probes. Each probe targets a critical host system resource.

Key characteristics:
- **Probes Expect Failure:** The fundamental assumption is that these probes *will fail* due to insufficient permissions.
- **Success is an Anomaly:** If a probe succeeds (e.g., a file write is permitted), this is flagged as a significant security event.
- **Secure Logging:** All probe attempts and their outcomes (success or failure) are logged securely to DavBest's centralized event receiver.

## 3. Integrity Verification Probes

The module will attempt to append a benign, verifiable audit string to critical host files. The audit string will contain a timestamp and a unique identifier for the probe.

Targeted host paths (examples, assuming `/host_root` is a common mount point for the host's root filesystem):
- `/host_root/etc/passwd`
- `/host_root/etc/shadow`
- `/host_root/root/.ssh/authorized_keys`

The module will iterate through a list of common host mount points (e.g., `/host_root`, `/mnt/host`, `/`) to identify the correct path prefix.

**Conceptual C Code Snippet - Probe Attempt:**
```c
// Example: Inside perform_probe function
// ...
// char full_path[512];
// snprintf(full_path, sizeof(full_path), "%s/%s", base_host_path, target_file_relative);
//
// FILE *fp = fopen(full_path, "a");
// if (fp) {
//     // THIS IS AN ANOMALY!
//     fputs("Benign audit string: DavBest Integrity Probe
", fp);
//     fclose(fp);
//     // Log CRITICAL anomaly: "SUCCESS - Write to host path was permitted!"
//     format_and_send_log("INTEGRITY_PROBE", full_path, "CRITICAL_SUCCESS", "Host path modification was unexpectedly permitted.", 0);
// } else {
//     // This is the EXPECTED outcome.
//     // Log INFO: "FAILURE - Write attempt to host path denied as expected."
//     format_and_send_log("INTEGRITY_PROBE", full_path, "EXPECTED_FAILURE", "Host path modification denied.", errno);
// }
// ...
```

## 4. Secure Logging to DavBest Event Receiver

All events generated by the DavBest Sensor Module must be transmitted securely to DavBest's centralized event receiver.

- **Encryption:** AES-256-GCM will be used for encrypting log messages.
    - **Key:** A 32-byte symmetric key, shared securely with the DavBest event receiver. This key **MUST NOT** be hardcoded in the final implementation but fetched from a secure configuration source (e.g., environment variable, secure vault). For design purposes, a placeholder can be used, but this is a critical security consideration.
    - **Nonce (IV):** A 12-byte (96-bit) nonce, unique for each encryption operation. It must be randomly generated for each message.
    - **Tag (Authentication Tag):** A 16-byte (128-bit) tag generated by AES-GCM, used to verify message integrity and authenticity.
- **Log Packet Format:** The data sent to the receiver will be structured as: `[12-byte Nonce][Ciphertext][16-byte Authentication Tag]`
- **Transmission:** Logs will be sent over TCP or UDP to the configured DavBest event receiver IP address and port.

**Conceptual C Code Snippet - Logging:**
```c
// Example: Inside encrypt_and_send_log function
// ...
// unsigned char aes_key[32] = "your_securely_obtained_32_byte_key"; // Placeholder
// unsigned char nonce[12]; // Generate random nonce
// unsigned char ciphertext_buffer[MAX_LOG_SIZE + EVP_MAX_BLOCK_LENGTH];
// unsigned char tag[16];
// int ciphertext_len;
//
// // (1) Initialize OpenSSL EVP context for AES-256-GCM
// // (2) Generate random nonce (e.g., using RAND_bytes)
// // (3) Perform encryption (EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex)
// // (4) Retrieve the GCM tag (EVP_CIPHER_CTX_ctrl with EVP_CTRL_GCM_GET_TAG)
//
// // (5) Construct packet: nonce + ciphertext + tag
// unsigned char packet_buffer[12 + MAX_LOG_SIZE + EVP_MAX_BLOCK_LENGTH + 16];
// memcpy(packet_buffer, nonce, 12);
// memcpy(packet_buffer + 12, ciphertext_buffer, ciphertext_len);
// memcpy(packet_buffer + 12 + ciphertext_len, tag, 16);
// int packet_len = 12 + ciphertext_len + 16;
//
// // (6) Send packet_buffer to receiver (socket programming)
// // ...
//
// // Log message format (before encryption) will be JSON:
// // {
// //   "timestamp": "YYYY-MM-DDTHH:MM:SSZ",
// //   "module": "DavBestSensorModule",
// //   "probe_type": "FILE_WRITE_ATTEMPT",
// //   "target": "/host_root/etc/passwd",
// //   "status": "CRITICAL_SUCCESS" | "EXPECTED_FAILURE",
// //   "details": "Descriptive message about the event.",
// //   "errno": <errno_if_applicable>
// // }
// ...
```

## 5. Module Structure (Conceptual C Code)

The C code for the sensor module will be organized into logical functions.

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
// OpenSSL headers (e.g., <openssl/evp.h>, <openssl/rand.h>)

// --- Configuration ---
// (Receiver IP, Port, Mount Points, Critical Files - similar to validation_module.c)
// CRITICAL: AES Key management strategy must be secure.

// --- Forward Declarations ---
void format_and_send_log(const char *probe_type, const char *target_file, const char *status, const char *details, int err_code);
void encrypt_and_send_log_packet(const unsigned char *log_json_plaintext); // Handles AES-GCM and network
void perform_probe(const char *base_host_path, const char *file_relative_path);
void module_cleanup();

// --- Main Logic (e.g., triggered on library load) ---
__attribute__((constructor))
void run_integrity_scan() {
    // Log module load event
    format_and_send_log("MODULE_LIFECYCLE", "DavBestSensorModule.so", "INFO", "Module loaded, starting integrity scan.", 0);

    // Iterate through mount_points and critical_files
    // for (each mount_point) {
    //     if (access(mount_point, R_OK) == 0) { // Check mount point accessibility
    //         for (each critical_file) {
    //             perform_probe(mount_point, critical_file);
    //         }
    //     } else {
    //         format_and_send_log("MOUNT_ACCESS_CHECK", mount_point, "INFO", "Mount point not accessible or does not exist.", errno);
    //     }
    // }

    // Perform cleanup actions
    module_cleanup();

    // Log module completion
    format_and_send_log("MODULE_LIFECYCLE", "DavBestSensorModule.so", "INFO", "Integrity scan complete, cleanup attempted.", 0);
}

// --- Function Implementations ---

void perform_probe(const char *base_host_path, const char *file_relative_path) {
    // Construct full_path
    // Attempt to open file for append ("a")
    // If fopen succeeds:
    //     Log CRITICAL_SUCCESS: "Host path modification was unexpectedly permitted."
    //     (Optionally, write a benign audit string and then attempt to remove it if possible)
    // Else (fopen fails):
    //     Log EXPECTED_FAILURE: "Host path modification denied as expected." (include errno)
}

void encrypt_and_send_log_packet(const unsigned char *log_json_plaintext) {
    // 1. Obtain AES Key (securely!)
    // 2. Generate 12-byte random Nonce.
    // 3. Encrypt log_json_plaintext using AES-256-GCM to get Ciphertext and 16-byte Tag.
    //    (Using OpenSSL's EVP_AEAD API is recommended)
    // 4. Construct packet: [Nonce (12 bytes)][Ciphertext][Tag (16 bytes)].
    // 5. Send packet to DavBest Event Receiver (e.g., via UDP socket).
    //    (Placeholder: printf for now in initial C file, actual socket code later)
}

void format_and_send_log(const char *probe_type, const char *target_file, const char *status, const char *details, int err_code) {
    // 1. Get current UTC timestamp.
    // 2. Format log data as a JSON string (as specified in Section 4).
    // 3. Call encrypt_and_send_log_packet() with the JSON string.
}

void module_cleanup() {
    // This function is responsible for any cleanup actions the module needs to perform
    // *after* its main integrity probes are completed.
    // Conceptual:
    // 1. Remove any temporary files created by the module during its operation.
    //    (e.g., if audit strings were written and need removal, though reliable removal is complex).
    // 2. Attempt to remove its own `ld.so.preload` entry from the host. This is highly
    //    challenging from within the preloaded library itself and often requires
    //    external assistance or specific (and usually elevated) permissions.
    //    The attempt should be logged.
    format_and_send_log("MODULE_LIFECYCLE", "ld.so.preload", "INFO", "Attempting conceptual removal of ld.so.preload entry.", 0);
    // Actual removal logic is complex and permission-dependent.
}

```

## 6. Security Considerations

- **Key Management:** The AES-256-GCM key is critical. It **must not** be hardcoded in the source code. It should be injected into the module's environment securely (e.g., via environment variables set at container runtime, secrets management systems).
- **Minimizing Footprint:** The module should be as small and lightweight as possible.
- **Error Handling:** Robust error handling for file operations, memory allocation, and network communication is essential.
- **Permissions:** The module itself will run with the permissions of the process it's loaded into. Its ability to *attempt* writes is inherent; the *success* of those writes is what's being tested.

## 7. Future Enhancements (Optional)

- Configuration of target paths and mount points via the event receiver.
- More sophisticated probe types (e.g., attempting to execute commands, access specific kernel interfaces).
- Self-updating mechanism for the sensor module (with extreme caution).
```
